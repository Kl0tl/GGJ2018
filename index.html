<!DOCTYPE html>
<html>
<head>
	<title>GGJ 2018</title>
	<style>
		.scene {
			display: none;
		}
		.scenes[data-selected="Rules"] .scene[data-scene="Rules"],
		.scenes[data-selected="Intro"] .scene[data-scene="Intro"],
		.scenes[data-selected="Loading"] .scene[data-scene="Loading"],
		.scenes[data-selected="Game"] .scene[data-scene="Game"] {
			display: block;
		}

		.pings-layer, .players-layer {
			position: relative;
		}

		.player {
			position: absolute;
		}

		.player.exit {
			animation: 1s ease-in fadeout;
		}

		@keyframes fadeout {
			from { opacity: 1; }
			to { opacity: 0; }
		}

		.pulse {
			position: absolute;
			width: 5px; height: 5px;
			border-radius: 50%;
			background-color: black;
		}
		.pulse:after {
			content: '';
			position: absolute;
			top: 50%; left: 50%;
			border-radius: 50%;
			animation: 1s ease-in pulse infinite;
			transform: translateX(-50%) translateY(-50%);
		}

		.players-layer .pulse {
			width: 0; height: 0;
			top: -5px;
		}

		@keyframes pulse {
			from {
				border: 1px solid rgba(0, 0, 0, 1);
				width: 0px; height: 0px;
			}
			to {
				border: 1px solid rgba(0, 0, 0, 0);
				width: 25px; height: 25px;
			}
		}

		.colors .color {
			display: inline-block;
			width: 15px;
			height: 15px;
			margin: 1px;
		}

		.color[data-color="chartreuse"] {
			background-color: chartreuse;
		}
		.colors[data-selected="chartreuse"] .color[data-color="chartreuse"] {
			border: 1px solid black;
			margin: 0;
		}
		.color[data-color="magenta"] {
			background-color: magenta;
		}
		.colors[data-selected="magenta"] .color[data-color="magenta"] {
			border: 1px solid black;
			margin: 0;
		}

		.maze-layer{
			border: 1px solid black;
		}

		.maze-cell{
			float: left;
			box-sizing: border-box;
			background: #888;
		}

		.layers{
			position: relative;
		}

		.layers > *:not(.maze-layer){
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
		}
	</style>
</head>
<body>
	<div id="root">
		<div class="scenes" data-selected="Rules">
			<div class="scene" data-scene="Rules">
				<button>Go to intro</button>
			</div>
			<div class="scene" data-scene="Intro">
				<button>Go to game</button>
			</div>
			<div class="scene" data-scene="Loading">
				Loadingâ€¦
			</div>
			<div class="scene" data-scene="Game">
			  <div class="layers">
			  	<div class="maze-layer"></div>
			  	<div class="players-layer"></div>
			  	<div class="pings-layer"></div>
			  	<canvas class="paths-layer"></canvas>
			  </div>
			  <div class="controls">
			  	<div class="draw">
			    	<button>Draw</button>
			    	<div class="colors" data-selected="chartreuse">
			    		<span class="color" data-color="chartreuse"></span>
			    		<span class="color" data-color="magenta"></span>
			    	</div>
			    </div>
			    <div class="ping">
			    	<button>Ping</button>
			    </div>
			  </div>
			</div>
			<div class="scene" data-scene="outro"></div>
		</div>
	</div>
	<script src="Maze.js"></script>
	<script src="binaural-fir.min.js"></script>
	<script src="complete_hrtfs.js"></script>
	<script>
		class Mouse {
			constructor() {
				this.trail = {
					start: { x: 0, y: 0 },
					end: { x: 0, y: 0 }
				};
				this.down = false;
				this.onMouseDown = this.onMouseDown.bind(this);
				this.onMouseUp = this.onMouseUp.bind(this);
				this.onMouseMove = this.onMouseMove.bind(this);
			}

			flush() {
				this.trail.start.x = this.trail.end.x;
				this.trail.start.y = this.trail.end.y;
			}

			track(element) {
				element.addEventListener('mousedown', this.onMouseDown);
				element.addEventListener('mouseup', this.onMouseUp);
				element.addEventListener('mousemove', this.onMouseMove);
				element.addEventListener('mouseleave', this.onMouseLeave);
				this.tracking = true;
			}

			untrack(element) {
				element.removeEventListener('mousedown', this.onMouseDown);
				element.removeEventListener('mouseup', this.onMouseUp);
				element.removeEventListener('mousemove', this.onMouseMove);
				element.removeEventListener('mouseleave', this.onMouseLeave);
				this.tracking = false;
			}

			onMouseDown(event) {
				this.down = true;
				this.trail.start.x = event.offsetX;
				this.trail.start.y = event.offsetY;
			}

			onMouseUp() {
				this.down = false;
			}

			onMouseMove(event) {
				this.trail.end.x = event.offsetX;
				this.trail.end.y = event.offsetY;
			}

			onMouseLeave() {
				this.down = false;
			}
		}

		class Player {
			constructor({ position, orientation, size }) {
				this.element = document.createElement('span');
				this.element.classList.add('player');
				this.size = size;
				this.element.style.top = this.size * position.y + 'px';
				this.element.style.left = this.size * position.x + 'px';
				this.position = position;
				this.orientation = orientation;
				this.idle = true;

				this.element.style.borderTop = this.size + "px solid black";
				this.element.style.borderLeft = this.size/2 +"px solid transparent";
				this.element.style.borderRight = this.size/2 +"px solid transparent";
			}

			move(alpha, { clockwise = true }) {
				this.position.x += this.size * Math.cos(alpha) * (clockwise ? 1 : -1);
				this.position.y += this.size * Math.sin(alpha) * (clockwise ? 1 : -1);
				this.element.style.top = this.position.y + 'px';
				this.element.style.left = this.position.x + 'px';
				this.idle = false;
			}

			rotate(alpha, { clockwise = true }) {
				this.orientation += alpha * (clockwise ? 1 : -1);
				this.element.style.transform = `rotateZ(${this.orientation}rad)`;
				this.idle = false;
			}

			update(gamepad) {
				if (this.idle) {
					if (gamepad.buttons[4].pressed) { // L1
						this.move(this.orientation, { clockwise: true });
					} else if (gamepad.buttons[5].pressed) { // R1
						this.move(this.orientation, { clockwise: false });
					} else if (gamepad.buttons[12].pressed) { // up
						this.move(this.orientation + Math.PI / 2, { clockwise: true });
					} else if (gamepad.buttons[13].pressed) { // down
						this.move(this.orientation + Math.PI / 2, { clockwise: false });
					} else if (gamepad.buttons[14].pressed) { // left
						this.rotate(Math.PI / 2, { clockwise: false });
					} else if (gamepad.buttons[15].pressed) { // right
						this.rotate(Math.PI / 2, { clockwise: true });
					}
				} else {
					this.idle = gamepad.buttons.every(button => !button.pressed);
				}
			}
		}
		class Pulse {
			constructor({ audio, assets, removable } = {}) {
				this.element = document.createElement('span');
				this.element.classList.add('pulse');
				if (removable) {
					this.onClick = this.onClick.bind(this);
					this.element.addEventListener('click', this.onClick);
				}
				this.audio = {
					source: audio.createBufferSource(),
					panner: new BinauralFIR({audioContext: audio})
				};
				this.audio.panner.HRTFDataset = hrtfs;
				this.audio.source.buffer = assets['./ameno.mp3'];
				this.audio.source.connect(this.audio.panner.input);
				this.audio.panner.connect(audio.destination);
				this.audio.source.loop = false;
				this.audio.panner.setPosition(-90, 0, 2);
			}

			onClick(event) {
				this.element.remove();
				this.audio.source.stop();
				event.stopPropagation();
			}
		}

		class Game {
		  constructor({ element, assets, audio, width, height }) {
		  	this.assets = assets;
		  	this.audio = audio;
		    this.mouse = new Mouse();
		    this.element = element;
		    this.cellSize = 30;
		    this.layers = {
		    	maze: {
		    		element: element.querySelector('.layers .maze-layer')
		    	},
		    	pings: {
		    		element: element.querySelector('.layers .pings-layer')
		    	},
		    	paths: {
		    		element: element.querySelector('.layers .paths-layer'),
		    		color: element.querySelector('.controls .draw .colors')
		    			.getAttribute('data-selected'),
		    		radius: 4
		    	},
		    	players: {
		    		element: element.querySelector('.layers .players-layer'),
		    		lifetime: 3000,
		    		cooldown: 30000,
		    		lastPingAt: 0,
		    	}
		    };
		    this.layers.paths.context = this.layers.paths.element.getContext('2d');
		    this.maze = new Maze({ audio: this.audio, width, height, cellSize: this.cellSize });

		    this.layers.paths.element.width = width * this.cellSize;
		    this.layers.paths.element.height = height * this.cellSize;

				// HRTF files loading
				for (var i = 0; i < hrtfs.length; i++) {
						var buffer = this.audio.createBuffer(2, 512, 44100);
						var bufferChannelLeft = buffer.getChannelData(0);
						var bufferChannelRight = buffer.getChannelData(1);
						for (var e = 0; e < hrtfs[i].fir_coeffs_left.length; e++) {
								bufferChannelLeft[e] = hrtfs[i].fir_coeffs_left[e];
								bufferChannelRight[e] = hrtfs[i].fir_coeffs_right[e];
						}
						hrtfs[i].buffer = buffer;
				}

		    this.player = new Player({
		    	position: this.maze.startPos,
		    	orientation: 0,
		    	size: this.cellSize
		    });
		    this.ping = new Pulse({
					audio: this.audio,
					assets: this.assets,
					removable: true
				});

		    this.onEnablePinging = this.onEnablePinging.bind(this);
		    this.onEnableDrawing = this.onEnableDrawing.bind(this);
		    this.onSelectColor = this.onSelectColor.bind(this);
		    this.onPing = this.onPing.bind(this);
		  }

		  onStart() {
		  	this.element.querySelector('.controls .ping button')
		  		.addEventListener('click', this.onEnablePinging);
		    this.element.querySelector('.controls .draw button')
		    	.addEventListener('click', this.onEnableDrawing);
		    this.element.querySelector('.controls .draw .colors')
		    	.addEventListener('click', this.onSelectColor);
		    this.mouse.track(this.layers.paths.element);
		    this.layers.players.element.appendChild(this.player.element);
		    this.maze.create();
		    this.maze.render( this.layers.maze.element );
		  }

		  onEnablePinging() {
		  	this.layers.pings.element.addEventListener('click', this.onPing);
		  	this.mouse.untrack(this.layers.paths.element);
		  	this.layers.paths.element.after(this.layers.pings.element);
		  }

		  onPing(event) {
		  	this.ping.element.style.left = event.offsetX - 2.5 + 'px';
		  	this.ping.element.style.top = event.offsetY - 2.5 + 'px';
		  	if (!this.ping.element.parentElement) {
		  		this.layers.pings.element.appendChild(this.ping.element);
		  	}
				this.ping.audio.source.start();
		  }

		  onEnableDrawing() {
		  	this.mouse.track(this.layers.paths.element);
		  	this.layers.paths.element.removeEventListener('click', this.onPing);
		  	this.layers.pings.element.after(this.layers.paths.element);
		  }

		  onSelectColor(event) {
		  	const color = event.target.getAttribute('data-color');
		  	if (color) {
		  		this.layers.paths.color = color;
		  		event.target.parentElement.setAttribute('data-selected', color);
		  		if (!this.mouse.tracking) this.onEnableDrawing();
		  	}
		  }

		  onEachFrame() {
		  	const gamepad = navigator.getGamepads()[0];
		  	if (gamepad) {
		  		const canPing = this.layers.players.lastPingAt + this.layers.players.cooldown < Date.now();
		  		const isPinging = [0, 1, 2, 3].some(index => {
		  			return gamepad.buttons[index].pressed;
		  		});

		  		if (this.player.idle && isPinging && canPing) {
		  			const ghost = new Player(this.player);
		  			const pulse = new Pulse({ removable: false });
		  			ghost.element.appendChild(pulse.element);
		  			this.layers.players.element.appendChild(ghost.element);
		  			this.player.idle = false;
		  			this.layers.players.lastPingAt = Date.now();
		  			setTimeout(() => {
		  				ghost.element.classList.add('exit');
		  				ghost.element.addEventListener('animationend',
		  					() => ghost.element.remove());
		  			}, this.layers.players.lifetime);
		  		} else {
		  			this.player.update(gamepad);
		  		}
		  	}
		  	if (this.mouse.tracking && this.mouse.down) {
		  		this.layers.paths.context.strokeStyle = this.layers.paths.color;
		  		this.layers.paths.lineWidth = this.layers.paths.radius;
		  		this.layers.paths.context.beginPath();
		  			this.layers.paths.context.moveTo(this.mouse.trail.start.x,
		  				this.mouse.trail.start.y);
		  			this.layers.paths.context.lineTo(this.mouse.trail.end.x,
		  				this.mouse.trail.end.y);
		  			this.layers.paths.context.stroke();
		  		this.mouse.flush();
		  	}
		  }
		}

		class Rules {
			constructor({ element, onExit }) {
				this.element = element;
				this.onExit = onExit;
			}

			onStart() {
				this.element.querySelector('button')
					.addEventListener('click', this.onExit);
			}
		}

		class Intro {
			constructor({ element, onExit }) {
				this.element = element;
				this.onExit = onExit;
			}

			onStart() {
				this.element.querySelector('button')
					.addEventListener('click', this.onExit);
			}
		}

		class Loading {
			constructor({ element, loaded, onExit }) {
				this.element = element;
				this.loaded = loaded;
				this.onExit = onExit;
			}

			onStart() {
				this.loaded.then(this.onExit);
			}
		}

		class AudioLoader {
			constructor(context) {
				this.context = context;
				this.cache = {};
			}

			load(url) {
				return new Promise((resolve, reject) => {
					const request = new XMLHttpRequest();
					request.open('GET', url, true);
					request.responseType = 'arraybuffer';
					request.onload = () => {
						this.context.decodeAudioData(request.response, buffer => {
							this.cache[url] = buffer;
							resolve(buffer);
						}, reject);
					};
					request.onerror = reject;
					request.send();
				});
			}
		}

		class Scenes {
			constructor({ element }) {
				const audio = new AudioContext();
				const loader = new AudioLoader(audio);
				this.element = element;
				this.game = new Game({
					element: element.querySelector('.scene[data-scene="Game"]'),
					assets: loader.cache,
					audio,
					width: 15,
					height: 15,
				});
				this.loading = new Loading({
					element: element.querySelector('.scene[data-scene="Loading"]'),
					loaded: loader.load('./ameno.mp3'),
					onExit: this.onEnter.bind(this, this.game)
				}),
				this.intro = new Intro({
					element: element.querySelector('.scene[data-scene="Intro"]'),
					onExit: this.onEnter.bind(this, this.loading)
				});
				this.rules = new Rules({
					element: element.querySelector('.scene[data-scene="Rules"]'),
					onExit: this.onEnter.bind(this, this.intro)
				});
				this.onEachFrame = this.onEachFrame.bind(this);
			}

			onStart() {
				this.onEnter(this.rules);
				this.onEachFrame();
			}

			onEnter(scene) {
				this.current = scene;
				this.current.onStart();
				this.element.setAttribute('data-selected',
					this.current.constructor.name);
			}

			onEachFrame() {
				if (this.current && this.current.onEachFrame) {
					this.current.onEachFrame();
				}
				requestAnimationFrame(this.onEachFrame);
			}
		}

		const scenes = new Scenes({
			element: document.querySelector('#root .scenes')
		});
		scenes.onStart();
	</script>
</body>
</html>
